package net.kaedenn.debugtoy.util;

import java.util.ArrayList;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.UnaryOperator;

@SuppressWarnings("unused")
public final class Functional {

    /** Call a function on every item in an array and return the results.
     *
     * This method calls the given function on each item in {@code seq}. The
     * results are placed in a new {@code ArrayList} and that {@code ArrayList}
     * is then returned.
     *
     * This method is functionally equivalent to the {@code map} family of
     * functions present in several other languages.
     *
     * @param seq The sequence on which to apply the function.
     * @param func The function to apply to the sequence.
     * @param <T> The input type; the function's parameter's type
     * @param <R> The output type; the function's return type
     * @return The new sequence generated by the function.
     */
    public static <T, R> ArrayList<R> map(ArrayList<T> seq, Function<T, R> func) {
        ArrayList<R> res = new ArrayList<>();
        for (T t : seq) {
            res.add(func.apply(t));
        }
        return res;
    }

    /** Call a function on every item in the array and return the results.
     *
     * This method is identical to the above method with one exception: the
     * input and output item types are the same.
     *
     * @param seq The sequence on which to apply the function.
     * @param func The function to apply to the sequence.
     * @param <T> The item type for both the input and output sequences.
     * @return The new sequence generated by the function.
     */
    public static <T> ArrayList<T> map(ArrayList<T> seq, UnaryOperator<T> func) {
        ArrayList<T> res = new ArrayList<>();
        for (T t : seq) {
            res.add(func.apply(t));
        }
        return res;
    }

    /** Replace every item in the array with the result of the given function.
     *
     * This method calls the given function on each item in the sequence and
     * then stores the results in-place.
     *
     * @param seq The sequence on which to apply the function.
     * @param func The function to apply to the sequence.
     * @param <T> The sequence's item type.
     */
    public static <T> void apply(ArrayList<T> seq, UnaryOperator<T> func) {
        for (int i = 0; i < seq.size(); ++i) {
            seq.set(i, func.apply(seq.get(i)));
        }
    }

    /** Replace every item in the array with the result of the given function.
     *
     * This method is identical to the one above but works on native arrays.
     *
     * @param seq The array on which to apply the function.
     * @param func The function to apply to the array.
     * @param <T> The item type of the array.
     */
    public static <T> void apply(T[] seq, UnaryOperator<T> func) {
        for (int i = 0; i < seq.length; ++i) {
            seq[i] = func.apply(seq[i]);
        }
    }

    /** Call a function on each item in the sequence.
     *
     * This method acts like the above {@code map} methods where the given
     * function does not return a value.
     *
     * @param seq The sequence on which to apply the function.
     * @param func The function to apply to the sequence.
     * @param <T> The sequence's item type.
     */
    public static <T> void forEach(ArrayList<T> seq, Consumer<T> func) {
        for (T i : seq) {
            func.accept(i);
        }
    }

    /** Call a function on each item in the array.
     *
     * This method is identical to the one above but takes an array instead of a
     * sequence.
     *
     * @param seq The array on which to apply the function.
     * @param func The function to apply to the array.
     * @param <T> The item type of the array.
     */
    public static <T> void forEach(T[] seq, Consumer<T> func) {
        for (T i : seq) {
            func.accept(i);
        }
    }

    /** Convert the given array to an array of strings.
     *
     * @param items The array to convert.
     * @param <T> The item type for the input array.
     * @return An array generated by calling {@code toString()} on each item.
     */
    public static <T> String[] toStrings(T[] items) {
        String[] result = new String[items.length];
        for (int i = 0; i < items.length; ++i) {
            result[i] = items[i].toString();
        }
        return result;
    }

    /** Convert the given text array to an array of native integers.
     *
     * @param items The array of character sequences.
     * @return An array generated by calling {@code Integer.valueOf()} on each
     * item.
     */
    public static int[] toIntegerArray(CharSequence[] items) {
        int[] result = new int[items.length];
        for (int i = 0; i < items.length; ++i) {
            String s = items[i].toString();
            if (s.startsWith("0x")) {
                result[i] = Integer.valueOf(s, 16);
            } else {
                result[i] = Integer.parseInt(s);
            }
        }
        return result;
    }

    /** Convert the given text array to an array of native integers.
     *
     * @param items The array of character sequences.
     * @return An array generated by calling {@code Integer.valueOf()} on each
     * item.
     */
    public static long[] toLongArray(CharSequence[] items) {
        long[] result = new long[items.length];
        for (int i = 0; i < items.length; ++i) {
            String s = items[i].toString();
            if (s.startsWith("0x")) {
                result[i] = Long.valueOf(s, 16);
            } else {
                result[i] = Long.parseLong(s);
            }
        }
        return result;
    }

    /** Convert the given text array to an array of native floats.
     *
     * @param items The array of character sequences.
     * @return An array generated by calling {@code Float.valueOf()} on each
     * item.
     */
    public static float[] toFloatArray(CharSequence[] items) {
        float[] result = new float[items.length];
        for (int i = 0; i < items.length; ++i) {
            result[i] = items[i] == null ? Float.NaN : Float.parseFloat(items[i].toString());
        }
        return result;
    }

    /** Convert the given text array to an array of native doubles.
     *
     * @param items The array of character sequences.
     * @return An array generated by calling {@code Double.valueOf()} on each
     * item.
     */
    public static double[] toDoubleArray(CharSequence[] items) {
        double[] result = new double[items.length];
        for (int i = 0; i < items.length; ++i) {
            result[i] = items[i] == null ? Double.NaN : Double.parseDouble(items[i].toString());
        }
        return result;
    }

}
